\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{inputenc}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    language=Java,
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\begin{document}

\title{15 PUZZLE}
\author{Francisco Ribeiro, Matheus Bissacot, Sérgio Coelho}
\date{}

\maketitle

\section{Descrição}

Este é o "trabalho 1" feito por Francisco Ribeiro (up202104797), Matheus Bissacot (up202106708) e Sérgio Coelho (up202107951) para a cadeira de Inteligência Artificial do curso Ciência dos computadores, da faculdade de Ciências da Universidade do Porto.
\paragraph{}
A estrutura de dados utilizada para representar uma configuração de jogo foi uma lista de inteiros, por conta da importância da ordem ser essencial para a resolução do jogo.
\paragraph{}
A linguagem utilizada foi Java.

\subsection{Objetivo}

\begin{itemize}
\item Implementar um algoritmo para saber se um dado puzzle 15 é resolvível ou não.
\item Implementação dos operadores que transformam uma configuração de jogo na sua sucessora.
\end{itemize}

\subsection{Requisitos}

Java 8 ou superior.

\section{Execução}

Para executar o programa, basta correr o seguinte comando:

\begin{verbatim}
$ java Puzzle
\end{verbatim}

Introduzir a configuração inicial e final e apenas se for realizável o jogo será possivel interagir com os tabuleiros.

\section{Referências}

\href{https://youtu.be/YI1WqYKHi78}{Link do vídeo} que ajuda a entender melhor como conseguimos ver se um jogo é fazivél.

\section{Código}
Todo o código se encontra neste 
\href{https://uporto-my.sharepoint.com/:f:/g/personal/up202104797_up_pt/Ep9LE7M38mhKmNeU8LD1JgkBAHS8VuRFmtuByZFLVfADSg?e=8jckQC}{link}, aqui estará todo completo com alguns extras apenas para ser mais bonito visualmente, mas nao estará no relatório para ser mais legível.
\paragraph{}
Implementação de uma classe para representar qualquer configuração de jogo com algumas funções auxiliares, como se é realizavél chegar de um tabuleiro inicial para qualquer final "isSolvable", assim como também aplicar movimentos ('u' cima, 'd' baixo, 'r' direita, 'l' esquerda ) a uma configuração (itable) certificando-se que são legais, "movements".
\paragraph{}
\begin{lstlisting}[frame=single]
class TABULEIRO {
    int[] initialTable; //tabela inicial
    int[] finalTable;   //tabela final
    int[] itable;       //tabela interativa

    TABULEIRO(){
        initialTable = new int[16];
        finalTable = new int[16];
        itable=new int[16]; //interactive table
    }

    void read(Scanner in){
        for(int i = 0; i < 16; i++) initialTable[i] = in.nextInt();
        for(int j = 0; j < 16; j++) finalTable[j] = in.nextInt();
        itable= Auxiliares.copyList(initialTable);
    }


    //limites
    public boolean limites(int pos, char direcao) {
        switch(direcao) {
            case 'u': //Up
                if(pos >= 0 && pos < 4) {
                    return false;
                }
                break;
            case 'd': //Down
                if(pos >= 12 && pos < 15) {
                    return false;
                }
                break;
            case 'l': //Left
                if(pos == 0 || pos == 4 || pos == 8 || pos == 12) {
                    return false;
                }
                break;
            case 'r': //Right
                if(pos == 3 || pos == 7 || pos == 11 || pos == 15) {
                    return false;
                }
                break;
        }

        return true;
    }

    
    //modificar com os movimentos, "u" para cima, "d" para baixo, "l" para esquerda e "r" para direita
    public boolean movements(char direction) {
        int pos = Auxiliares.findIndex(itable, 0);
        int temp = itable[pos];
        
        switch(direction) {
            case 'u': //Up
                if(limites(pos, 'u')) {
                    itable[pos] = itable[pos - 4];
                    itable[pos - 4] = temp;
                    return true;
                }
            break;
            case 'd': //Down
                if(limites(pos, 'd')) {
                    itable[pos] = itable[pos + 4];
                    itable[pos + 4] = temp;
                    return true;
                }
            break;
            case 'l': //Left
                if(limites(pos, 'l')) {
                    itable[pos] = itable[pos - 1];
                    itable[pos - 1] = temp;
                    return true;
                }
            break;
            case 'r': //Right
                if(limites(pos, 'r')) {
                    itable[pos] = itable[pos + 1];
                    itable[pos + 1] = temp;
                    return true;
                }
            break;
        }

        return false;
    }


    //imprimir o jogo atual
    public String toString() {
        String res = "";
        for(int i = 0; i < 16; i++) {
            if(i%4 == 0) {
                if (i==0) res = "\n";
                else res += "|\n";
                res += "+---------------+\n";
            }
            if (itable[i]<10){
                res += "|"+ itable[i] + "  ";
            }
            else{
                res += "|"+itable[i] + " ";
            }
        }
        res+="|"+"\n+---------------+";
        res += "\n";
        return res;
    }


    int SaltosBranco(){
        int pos = Auxiliares.findIndex(initialTable, 0);
        int pos_final = Auxiliares.findIndex(finalTable, 0);
        //as linhas sao os grupos (0-3)(4-7)(8-11)(12-15)
        int dist_vertical = (pos_final/4) - (pos/4);
        int dist_horizontal = (pos_final%4) - (pos%4);
        //distancia tem de ser positiva
        if(dist_vertical < 0) {
            dist_vertical = dist_vertical * -1;
        }    
        if(dist_horizontal < 0) {
            dist_horizontal = dist_horizontal * -1;
        }
        int distancia_final = dist_vertical + dist_horizontal;
        return distancia_final;
    }

    //Verificar se um puzzle e realizavel
    public boolean isSolvable() {
        int[] temp = Auxiliares.copyList(initialTable);
        int inv = 0; //Permutations
        int distancia_brancos = SaltosBranco(); //Distancia dos brancos

        for(int i = 0; i < 16; i++) {
            if(temp[i] != finalTable[i]) {
                for(int j = Auxiliares.findIndex(temp, finalTable[i]); j > i; j--) {
                    int temporario = temp[j - 1];
                    temp[j - 1] = temp[j];
                    temp[j] = temporario;
                    inv++;
                }
            }
        }

        return (distancia_brancos%2 == 0) == (inv%2 == 0);
    }

}
\end{lstlisting}
\paragraph{}
Para ser possível correr o código foi preciso implementar alguns métodos auxiliares, o nome dos mesmos são auto-explicativos.
\paragraph{}
\begin{lstlisting}[frame=single]
class Auxiliares{
    public static int findIndex(int[] table, int number) {
        int res = -1;
        for(int i = 0; i < table.length; i++) {
            if(table[i] == number) {
                res = i;
                break;
            }
        }

        return res;
    }
    //metodo para copiar duas listas de inteiros
    public static int[] copyList(int[] list) {
        int[] res = new int[list.length];
        for(int i = 0; i < list.length; i++) {
            res[i] = list[i];
        }

        return res;
    }

    //compara duas listas de inteiros
    public static boolean compare(int[] list1, int[] list2) {
        boolean res = true;
        for(int i = 0; i < list1.length; i++) {
            if(list1[i] != list2[i]) {
                res = false;
                break;
            }
        }

        return res;
    }

}

\end{lstlisting}
\paragraph{}
Por fim, para ser possível testar criamos uma classe com o método main em que cria um jogo e assim lê os tabuleiros dizendo se é realizável ou não. Se for, é possível interagir com o tabuleiro para se tentar chegar á configuração final desejada.
\paragraph{}
\begin{lstlisting}[frame=single]
import java.util.Scanner;


class Puzzle{
    static TABULEIRO teste= new TABULEIRO();
    
    public static void main(String[] args) {
        //Input Lines
        Scanner in = new Scanner(System.in);
        teste.read(in);

        if (teste.isSolvable()) {
            System.out.println("Tem solucao");
            interact(in);
        } else {
            System.out.println("Nao tem solucao");
            System.out.println("A sair...");
        }
    }

    //interagir com o puzzle
    public static void interact(Scanner in){
        System.out.println(teste);
        in.nextLine();

        //enquanto o carater nao for "q" ou "Q" continua a pedir input
        //o input e um carater de cada vez separado por mudanca de linha
        //se a table.itable for igual á finaltable, o puzzle esta resolvido e sai do loop
        while(in.hasNext()){
            char input = in.next().charAt(0);
            if(input == 'q' || input == 'Q') {
                System.out.println("A sair... :(");
                break;
            }
            if(teste.movements(input)) {
                System.out.println(teste);
            }
            else{
                System.out.println("Movimento invalido, tente novamente");
            }

            if(Auxiliares.compare(teste.itable, teste.finalTable)) {
                System.out.println("Puzzle Resolvido");
                break;
            }
        }
    }
}
\end{lstlisting}

\end{document}